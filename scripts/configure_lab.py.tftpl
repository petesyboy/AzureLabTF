import requests
import time
import json
import sys
import urllib3
import os
import subprocess
import shutil

# Suppress insecure request warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ==============================================================================
# CONFIGURATION (Populated by Terraform)
# ==============================================================================
FM_IP = "${fm_ip}"
FM_URL = f"https://{FM_IP}"

# FM Configuration Defaults
FM_GROUP = "${fm_group}"
FM_SUBGROUP = "${fm_subgroup}"
VSERIES_IP = "${vseries_ip}"
UCTV_CONTROLLER_IP = "${uctv_controller_ip}"
PROD1_IP = "${prod1_ip}"
PROD2_IP = "${prod2_ip}"

# Azure Key Vault (optional convenience for local script)
# If you uploaded the FM token to Key Vault, this script can read it using Azure CLI.
KEY_VAULT_NAME = "${key_vault_name}"
FM_TOKEN_SECRET_NAME = "${fm_token_secret_name}"

# FM API Token â€” leave empty to be prompted at runtime.
# Generate from FM UI: Administration > User Management > Tokens > Current User Tokens
# Token is used for both FM REST API calls and agent registration in gigamon-cloud.conf
FM_TOKEN = ""

# Built at runtime after token is obtained
AUTH_HEADERS = {}

def check_fm_accessible():
    """Checks if FM API is reachable and ready."""
    url = f"{FM_URL}/api/v1.3/user" 
    print(f"Waiting for FM API to become ready (this can take 5-10 minutes after boot)...")
    print(f"Checking URL: {url} for a valid JSON API response")
    
    max_retries = 60
    for i in range(max_retries):
        try:
            # Send a request with dummy auth. If the API is up, it will return a 401/403 with JSON.
            # If the web server is up but API isn't, it often returns 502, 503, or an HTML redirect.
            resp = requests.get(url, verify=False, timeout=5, auth=("dummy", "dummy"))
            
            # If the response contains JSON, it means the backend API has initialized
            if "application/json" in resp.headers.get("Content-Type", ""):
                print("\nFM API is ready!")
                return True
            else:
                sys.stdout.write(".")
                sys.stdout.flush()
        except requests.exceptions.RequestException:
            sys.stdout.write("_")
            sys.stdout.flush()
        
        time.sleep(10)
        
    print("\nTimeout waiting for FM API. Please check the VM status.")
    return False

def get_auth_token():
    """Returns the FM API JWT token for use in API calls and agent registration."""
    print("\n" + "="*60)
    print("GigaVUE-FM Authentication")
    print("="*60)

    token = FM_TOKEN.strip()
    token_source = "FM_TOKEN constant"

    # 1) Allow env var override (useful for automation)
    if not token:
        env_token = (os.environ.get("GIGAMON_FM_TOKEN") or "").strip()
        if env_token:
            token = env_token
            token_source = "env:GIGAMON_FM_TOKEN"
        else:
            env_token = (os.environ.get("FM_TOKEN") or "").strip()
            if env_token:
                token = env_token
                token_source = "env:FM_TOKEN"

    # 2) Convenience: If user uploaded token to Key Vault, try to read it via Azure CLI.
    # This does NOT store the token in Terraform state; it simply reads the already-uploaded secret.
    if not token and KEY_VAULT_NAME and FM_TOKEN_SECRET_NAME:
        print(f"  Attempting to retrieve token from Azure Key Vault '{KEY_VAULT_NAME}' (Secret: '{FM_TOKEN_SECRET_NAME}')...")
        try:
            az_cmd = shutil.which("az") or ("az.cmd" if os.name == "nt" else "az")
            az = subprocess.run(
                [
                    az_cmd, "keyvault", "secret", "show",
                    "--vault-name", KEY_VAULT_NAME,
                    "--name", FM_TOKEN_SECRET_NAME,
                    "--query", "value",
                    "-o", "tsv",
                ],
                capture_output=True,
                text=True,
                check=True,
            )
            token = (az.stdout or "").strip()
            if token:
                print(f"  [SUCCESS] Retrieved token from Key Vault '{KEY_VAULT_NAME}' secret '{FM_TOKEN_SECRET_NAME}'.")
                token_source = f"azure-key-vault:{KEY_VAULT_NAME}/{FM_TOKEN_SECRET_NAME}"
            else:
                print(f"  [WARNING] Azure CLI executed successfully, but returned an empty token. Check if the secret exists and has a value.")
        except FileNotFoundError:
            print("  [ERROR] Azure CLI not found on PATH. Install Azure CLI or use env:GIGAMON_FM_TOKEN.")
        except subprocess.CalledProcessError as e:
            print(f"  [ERROR] Unable to read token from Azure Key Vault '{KEY_VAULT_NAME}'. Check your 'az login' status, permissions, and secret name.")
            if e.stderr:
                print(f"  Azure CLI stderr: {e.stderr.strip()}")
            if e.stdout:
                print(f"  Azure CLI stdout: {e.stdout.strip()}")
        except Exception as e:
            # Fall through to failure message
            print(f"  [ERROR] Unhandled exception reading token from Azure Key Vault.")
            if hasattr(e, "stderr") and e.stderr:
                print(f"  Azure CLI error: {e.stderr.strip()}")

    if not token:
        print("\n[ERROR] No FM token available for API calls.")
        print("This script is non-interactive and will not prompt for a token.")
        print("\nProvide the token using ONE of these methods:")
        print("  A) Upload to Key Vault (recommended) and ensure Azure CLI is logged in:")
        print(f"     az login")
        print(f"     az keyvault secret set --vault-name \"{KEY_VAULT_NAME}\" --name \"{FM_TOKEN_SECRET_NAME}\" --value \"<PASTE_FM_TOKEN_HERE>\"")
        print("     Then re-run this script.")
        print("\n  B) Set an environment variable and re-run:")
        print("     Windows PowerShell:  $env:GIGAMON_FM_TOKEN = \"<PASTE_FM_TOKEN_HERE>\"")
        print("     macOS/Linux:         export GIGAMON_FM_TOKEN=\"<PASTE_FM_TOKEN_HERE>\"")
        sys.exit(1)

    print(f"  Token source: {token_source}")
    print(f"  Token: {token[:20]}...{token[-10:]} ({len(token)} chars)")
    return token

def create_monitoring_domain(domain_alias):
    """Creates the Monitoring Domain via FM API using 'anyCloud' platform."""
    url = f"{FM_URL}/api/v1.3/cloud/monitoringDomains"

    # 1. Check existence
    print(f"Checking for existing domain at: {url}")
    try:
        resp = requests.get(url, headers=AUTH_HEADERS, verify=False)
        print(f"GET Response Code: {resp.status_code}")
        
        if resp.status_code == 200:
            try:
                data = resp.json()
                print(f"DEBUG: Domains Raw Response: {json.dumps(data, indent=2)}")
                
                # Handle wrapped response (common in Gigamon APIs)
                if isinstance(data, dict) and 'monitoringDomains' in data:
                    domains = data['monitoringDomains']
                elif isinstance(data, list):
                    domains = data
                else:
                    domains = [data] if isinstance(data, dict) else []

                for d in domains:
                    # Handle if d is a dict (expected)
                    if isinstance(d, dict) and d.get('alias') == domain_alias:
                        print(f"Monitoring Domain '{domain_alias}' already exists (ID: {d.get('id')}).")
                        return d.get('id')
                        
            except ValueError:
                print(f"GET Response was not JSON: {resp.text}")
                
        else:
            print(f"Failed to list domains. Status: {resp.status_code}")
            print(f"Response: {resp.text}")
    except Exception as e:
        print(f"Warning: Could not list cloud domains: {e}")

    # 2. Create
    print(f"\nCreating Monitoring Domain '{domain_alias}'...")
    
    # User provided payload
    payload = {
        "alias": domain_alias,
        "platform": "anyCloud",
        "userLaunched": True,
        "dualStackPreferIPv6": False,
        "mtu": 1450
    }

    try:
        response = requests.post(url, json=payload, headers=AUTH_HEADERS, verify=False)
        
        # Debugging POST response
        print(f"POST Response Code: {response.status_code}")
        
        if response.status_code in [200, 201]:
            # Try to get ID from response first
            try:
                data = response.json()
                if data and 'id' in data:
                    domain_id = data.get('id')
                    print(f"Successfully created Monitoring Domain (ID: {domain_id}).")
                    return domain_id
            except:
                pass
            
            print(f"POST succeeded ({response.status_code}). Retrieving ID via GET...")
            
            # Attempt to retrieve ID via GET since creation succeeded
            # Wait a moment for consistency?
            time.sleep(2) 
            try:
                resp = requests.get(url, headers=AUTH_HEADERS, verify=False)
                if resp.status_code == 200:
                    data = resp.json()
                    if isinstance(data, dict) and 'monitoringDomains' in data:
                        domains = data['monitoringDomains']
                    elif isinstance(data, list):
                        domains = data
                    else:
                        domains = []

                    for d in domains:
                        if isinstance(d, dict) and d.get('alias') == domain_alias:
                            print(f"Retrieved ID for newly created Domain: {d.get('id')}")
                            return d.get('id')
            except Exception as e:
                print(f"Error retrieving ID after creation: {e}")
                
            print("[!] Created Domain but could not retrieve ID automatically.")
            return None
                
        elif response.status_code == 409:
            # Non-interactive: domain exists; retrieve ID and continue.
            print(f"Monitoring Domain '{domain_alias}' already exists (409 Conflict). Retrieving its ID...")
            try:
                resp = requests.get(url, headers=AUTH_HEADERS, verify=False)
                if resp.status_code == 200:
                    data = resp.json()
                    if isinstance(data, dict) and 'monitoringDomains' in data:
                        domains = data['monitoringDomains']
                    elif isinstance(data, list):
                        domains = data
                    else:
                        domains = []

                    for d in domains:
                        if isinstance(d, dict) and d.get('alias') == domain_alias:
                            print(f"Found existing Domain ID: {d.get('id')}")
                            return d.get('id')
                print("[!] Domain exists but could not retrieve ID from API listing.")
                return None
            except Exception as e:
                print(f"[!] Domain exists but GET retry failed: {e}")
                return None
        else:
            print(f"Failed to create Monitoring Domain. API returned {response.status_code}")
            print(f"Response: {response.text}")
            return None
    except Exception as e:
        print(f"Error creating domain: {e}")
        return None

def create_anycloud_connection(domain_id, connection_alias):
    """Creates the AnyCloud Connection (Session) via FM API."""
    if not domain_id:
        print("Skipping Connection/Session creation (No Domain ID).")
        return

    url = f"{FM_URL}/api/v1.3/cloud/anyCloud/connections"

    print(f"\nCreating AnyCloud Connection '{connection_alias}'...")

    payload = {
        "alias": connection_alias,
        "monitoringDomainId": domain_id,
        "secureMirrorTraffic": False
    }

    try:
        response = requests.post(url, json=payload, headers=AUTH_HEADERS, verify=False)
        print(f"POST Response Code: {response.status_code}")
        
        if response.status_code in [200, 201]:
            print(f"Successfully created AnyCloud Connection '{connection_alias}'.")
        elif response.status_code == 409:
            print(f"AnyCloud Connection '{connection_alias}' already exists.")
        else:
            print(f"Failed to create Connection. API returned {response.status_code}")
            print(f"Response: {response.text}")
            
    except Exception as e:
        print(f"Error creating connection: {e}")

def push_uctv_config(token):
    """Pushes the registration token and config to the UCTV Controller via SSH."""
    if not UCTV_CONTROLLER_IP:
        return
        
    print(f"\n--- Step 2/4: Register UCTV Controller via SSH ---")
    print(f"Pushing configuration to UCTV Controller ({UCTV_CONTROLLER_IP})...")
    
    config_content = f"""Registration:
  groupName: {FM_GROUP}
  subGroupName: {FM_SUBGROUP}
  token: {token}
  remoteAddress: {FM_IP}
  remotePort: 443
"""
    
    ssh_cmd = [
        "ssh", "-i", "./lab_key.pem", "-o", "StrictHostKeyChecking=no",
        f"peter@{UCTV_CONTROLLER_IP}",
        "sudo bash -c 'cat > /etc/gigamon-cloud.conf && systemctl restart uctv-cntlr'"
    ]
    
    print(f"  Attempting SSH connection to peter@{UCTV_CONTROLLER_IP}...")
    try:
        process = subprocess.run(
            ssh_cmd, 
            input=config_content, 
            text=True, 
            capture_output=True,
            check=True
        )
        print("  [SUCCESS] Successfully wrote /etc/gigamon-cloud.conf and restarted uctv-cntlr service.")
    except FileNotFoundError:
        print("  [ERROR] 'ssh' command not found on PATH. Ensure SSH client is installed and accessible.")
    except subprocess.CalledProcessError as e:
        print(f"  [ERROR] Failed to push config via SSH.")
        print(f"  Ensure 'lab_key.pem' is in the current directory.")
        if e.stderr:
            print(f"  SSH Error: {e.stderr.strip()}")
    except Exception as e:
        print(f"  [ERROR] Unhandled exception during SSH: {e}")

def push_vseries_config(token):
    """Pushes the registration token and config to the vSeries node via SSH."""
    if not VSERIES_IP:
        return
        
    print(f"\n--- Step 3/4: Register vSeries Node via SSH ---")
    print(f"Pushing configuration to vSeries node ({VSERIES_IP})...")
    
    config_content = f"""Registration:
  groupName: {FM_GROUP}
  subGroupName: {FM_SUBGROUP}
  token: {token}
  remoteAddress: {FM_IP}
  remotePort: 443
"""
    
    # Run SSH natively and pass the config via stdin to avoid quoting issues
    ssh_cmd = [
        "ssh", "-i", "./lab_key.pem", "-o", "StrictHostKeyChecking=no",
        f"peter@{VSERIES_IP}",
        "sudo bash -c 'cat > /etc/gigamon-cloud.conf && systemctl restart vseries-node'"
    ]
    
    print(f"  Attempting SSH connection to peter@{VSERIES_IP}...")
    try:
        process = subprocess.run(
            ssh_cmd, 
            input=config_content, 
            text=True, 
            capture_output=True,
            check=True
        )
        print("  [SUCCESS] Successfully wrote /etc/gigamon-cloud.conf and restarted vseries-node service.")
    except FileNotFoundError:
        print("  [ERROR] 'ssh' command not found on PATH. Ensure SSH client is installed and accessible.")
    except subprocess.CalledProcessError as e:
        print(f"  [ERROR] Failed to push config via SSH.")
        print(f"  Ensure 'lab_key.pem' is in the current directory.")
        if e.stderr:
            print(f"  SSH Error: {e.stderr.strip()}")
    except Exception as e:
        print(f"  [ERROR] Unhandled exception during SSH: {e}")

def restart_ubuntu_agents():
    """Restarts the UCTV agent on the production Ubuntu VMs via SSH."""
    print(f"\n--- Step 4/4: Restart Ubuntu UCTV Agents via SSH ---")
    for ip, name in [(PROD1_IP, "prod-ubuntu-1"), (PROD2_IP, "prod-ubuntu-2")]:
        if not ip:
            continue
        print(f"Restarting uctv agent daemon on {name} ({ip})...")
        ssh_cmd = [
            "ssh", "-i", "./lab_key.pem", "-o", "StrictHostKeyChecking=no",
            f"peter@{ip}",
            "sudo systemctl restart uctv"
        ]
        try:
            subprocess.run(ssh_cmd, capture_output=True, check=True)
            print(f"  [SUCCESS] Successfully restarted uctv service on {name}.")
        except Exception as e:
            print(f"  [WARNING] Could not restart agent on {name}. It may restart automatically later via timer.")

def main():
    print("---------------------------------------------------------")
    print("   Gigamon V Series - FM API Configuration")
    print("---------------------------------------------------------")

    if not check_fm_accessible():
        print("FM is not reachable. Is the VM running?")
        sys.exit(1)

    # 1. Get FM API token (prompts if not hardcoded)
    agent_token = get_auth_token()

    # Build auth headers from the token
    global AUTH_HEADERS
    AUTH_HEADERS = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "Authorization": f"Bearer {agent_token}"
    }

    monitoring_domain = FM_GROUP
    subgroup_name = FM_SUBGROUP

    print("\n" + "="*60)
    print("Configuration Summary")
    print("="*60)
    print(f"  FM:               {FM_URL}")
    print(f"  Monitoring Domain: {monitoring_domain}")
    print(f"  Connection:        {subgroup_name}")
    print()

    # FM API Configuration (Monitoring Domain + Connection)
    print("--- Step 1/1: FM API Configuration ---")
    print(f"Creating Monitoring Domain '{monitoring_domain}'...")

    domain_id = create_monitoring_domain(monitoring_domain)

    if domain_id:
        create_anycloud_connection(domain_id, subgroup_name)
    else:
        print("\n[WARNING] Monitoring Domain creation failed or skipped.")
        print("You can retry later once FM is fully initialized.")

    # 3. Register the UCTV node via SSH
    push_uctv_config(agent_token)

    # 4. Register the vSeries node via SSH
    push_vseries_config(agent_token)

    # 5. Restart the production Ubuntu agents to force immediate registration
    restart_ubuntu_agents()

    print("\n" + "="*60)
    print("Configuration Complete!")
    print("="*60)
    print(f"  Verify in FM:  {FM_URL}/app/#/cloud/monitoringDomains")
    print(f"  Domain:        {monitoring_domain}")
    print(f"  Connection:    {subgroup_name}")
    print("\nUCT-V Agent (Workloads) registration: Handled by cloud-init + Key Vault.")
    print("UCT-V Controller registration: Handled by SSH direct push.")
    print("vSeries Node registration: Handled by SSH direct push.")
    print("="*60)

if __name__ == "__main__":
    main()
