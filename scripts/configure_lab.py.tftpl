import requests
import time
import json
import sys
import subprocess
import urllib3
import os

# Suppress insecure request warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ==============================================================================
# CONFIGURATION (Populated by Terraform)
# ==============================================================================
FM_IP = "${fm_ip}"
FM_URL = f"https://{FM_IP}"
UCTV_IP = "${uctv_ip}"
UCTV_PUBLIC_IP = "${uctv_public_ip}"
VSERIES_PUBLIC_IP = "${vseries_public_ip}"
TOOL_PUBLIC_IP = "${tool_public_ip}"
PROD_IPS = "${prod_ips}".split(",")
KEY_PATH = "${key_path}"
USERNAME = "${username}"

# FM Configuration Defaults
FM_GROUP = "${fm_group}"
FM_SUBGROUP = "${fm_subgroup}"

# Azure Context (for Monitoring Domain)
SUBSCRIPTION_ID = "${subscription_id}"
TENANT_ID = "${tenant_id}"

# FM API Token â€” leave empty to be prompted at runtime.
# Generate from FM UI: Administration > User Management > Tokens > Current User Tokens
# Token is used for both FM REST API calls and agent registration in gigamon-cloud.conf
FM_TOKEN = ""

# Built at runtime after token is obtained
AUTH_HEADERS = {}

def run_ssh_command(ip, command, use_sudo=False):
    """Runs a command on a remote VM via SSH."""
    ssh_cmd = [
        "ssh",
        "-o", "StrictHostKeyChecking=no",
        "-o", "UserKnownHostsFile=/dev/null",
        "-tt", # Force pseudo-tty allocation
        "-i", KEY_PATH,
        f"{USERNAME}@{ip}",
    ]
    
    if use_sudo:
        command = f"sudo {command}"
        
    ssh_cmd.append(command)
    
    print(f"  [SSH] {USERNAME}@{ip}: {command[:80]}{'...' if len(command) > 80 else ''}")  

    try:
        # We need to capture output but -tt might mess with it slightly.
        # However, it's necessary for sudo.
        result = subprocess.run(ssh_cmd, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error running SSH command on {ip} (Exit Code {e.returncode}):")
        print(f"  STDOUT: {e.stdout}")
        print(f"  STDERR: {e.stderr}")
        return None

def check_fm_accessible():
    """Checks if FM API is reachable and ready."""
    url = f"{FM_URL}/api/v1.3/user" 
    print(f"Waiting for FM API to become ready (this can take 5-10 minutes after boot)...")
    print(f"Checking URL: {url} for a valid JSON API response")
    
    max_retries = 60
    for i in range(max_retries):
        try:
            # Send a request with dummy auth. If the API is up, it will return a 401/403 with JSON.
            # If the web server is up but API isn't, it often returns 502, 503, or an HTML redirect.
            resp = requests.get(url, verify=False, timeout=5, auth=("dummy", "dummy"))
            
            # If the response contains JSON, it means the backend API has initialized
            if "application/json" in resp.headers.get("Content-Type", ""):
                print("\nFM API is ready!")
                return True
            else:
                sys.stdout.write(".")
                sys.stdout.flush()
        except requests.exceptions.RequestException:
            sys.stdout.write("_")
            sys.stdout.flush()
        
        time.sleep(10)
        
    print("\nTimeout waiting for FM API. Please check the VM status.")
    return False

def get_auth_token():
    """Returns the FM API JWT token for use in API calls and agent registration."""
    print("\n" + "="*60)
    print("GigaVUE-FM Authentication")
    print("="*60)

    token = FM_TOKEN.strip()

    if not token:
        print("""
Before continuing, you need an FM API token.

To create one:
  1. Open https://{}  in your browser and log in as admin
  2. Go to: Administration > User Management > Tokens > Current User Tokens
  3. Click 'New Token'
  4. Set: Name = Lab_Token, Expiry = 105 days, User Group = Super Admin Group
  5. Click OK and COPY the full token string shown (it is only displayed once)
  6. Paste it below
""".format(FM_IP))
        token = input("Paste FM API token here: ").strip()
        if not token:
            print("No token provided. Exiting.")
            sys.exit(1)

    print(f"  Token: {token[:20]}...{token[-10:]} ({len(token)} chars)")
    return token

def _ssh_sed_set(vm_ip, key, value, config_path="/etc/gigamon-cloud.conf"):
    escaped_value = str(value).replace("|", "\\|")
    cmd = f"sed -i \"s|^\\\\([[:space:]]*{key}:\\\\).*|\\\\1 {escaped_value}|\" {config_path}"
    return run_ssh_command(vm_ip, cmd, use_sudo=True)

def push_registration_token(vm_ip, token, remote_address=None, remote_port=None):
    """Push token (and optionally remoteAddress/remotePort) and trigger agent refresh on the VM."""
    print(f"Pushing registration settings to {vm_ip}...")

    # Ensure config exists (cloud-init should have created it)
    if run_ssh_command(vm_ip, "test -f /etc/gigamon-cloud.conf && echo FOUND || echo NOT_FOUND") != "FOUND":
        print(f"  [!] /etc/gigamon-cloud.conf not found on {vm_ip}. Skipping.")
        return False

    _ssh_sed_set(vm_ip, "token", token)

    if remote_address is not None:
        _ssh_sed_set(vm_ip, "remoteAddress", remote_address)
    if remote_port is not None:
        _ssh_sed_set(vm_ip, "remotePort", remote_port)

    # The VM-side systemd path unit will also react to the file change,
    # but starting the oneshot makes this immediate/idempotent.
    run_ssh_command(vm_ip, "systemctl start gigamon-agent-refresh.service || true", use_sudo=True)
    return True

def create_monitoring_domain(domain_alias):
    """Creates the Monitoring Domain via FM API using 'anyCloud' platform."""
    url = f"{FM_URL}/api/v1.3/cloud/monitoringDomains"

    # 1. Check existence
    print(f"Checking for existing domain at: {url}")
    try:
        resp = requests.get(url, headers=AUTH_HEADERS, verify=False)
        print(f"GET Response Code: {resp.status_code}")
        
        if resp.status_code == 200:
            try:
                data = resp.json()
                print(f"DEBUG: Domains Raw Response: {json.dumps(data, indent=2)}")
                
                # Handle wrapped response (common in Gigamon APIs)
                if isinstance(data, dict) and 'monitoringDomains' in data:
                    domains = data['monitoringDomains']
                elif isinstance(data, list):
                    domains = data
                else:
                    domains = [data] if isinstance(data, dict) else []

                for d in domains:
                    # Handle if d is a dict (expected)
                    if isinstance(d, dict) and d.get('alias') == domain_alias:
                        print(f"Monitoring Domain '{domain_alias}' already exists (ID: {d.get('id')}).")
                        return d.get('id')
                        
            except ValueError:
                print(f"GET Response was not JSON: {resp.text}")
                
        else:
            print(f"Failed to list domains. Status: {resp.status_code}")
            print(f"Response: {resp.text}")
    except Exception as e:
        print(f"Warning: Could not list cloud domains: {e}")

    # 2. Create
    print(f"\nCreating Monitoring Domain '{domain_alias}'...")
    
    # User provided payload
    payload = {
        "alias": domain_alias,
        "platform": "anyCloud",
        "userLaunched": True,
        "dualStackPreferIPv6": False,
        "mtu": 1450
    }

    try:
        response = requests.post(url, json=payload, headers=AUTH_HEADERS, verify=False)
        
        # Debugging POST response
        print(f"POST Response Code: {response.status_code}")
        
        if response.status_code in [200, 201]:
            # Try to get ID from response first
            try:
                data = response.json()
                if data and 'id' in data:
                    domain_id = data.get('id')
                    print(f"Successfully created Monitoring Domain (ID: {domain_id}).")
                    return domain_id
            except:
                pass
            
            print(f"POST succeeded ({response.status_code}). Retrieving ID via GET...")
            
            # Attempt to retrieve ID via GET since creation succeeded
            # Wait a moment for consistency?
            time.sleep(2) 
            try:
                resp = requests.get(url, headers=AUTH_HEADERS, verify=False)
                if resp.status_code == 200:
                    data = resp.json()
                    if isinstance(data, dict) and 'monitoringDomains' in data:
                        domains = data['monitoringDomains']
                    elif isinstance(data, list):
                        domains = data
                    else:
                        domains = []

                    for d in domains:
                        if isinstance(d, dict) and d.get('alias') == domain_alias:
                            print(f"Retrieved ID for newly created Domain: {d.get('id')}")
                            return d.get('id')
            except Exception as e:
                print(f"Error retrieving ID after creation: {e}")
                
            print("[!] Created Domain but could not retrieve ID automatically.")
            return None
                
        elif response.status_code == 409:
            print(f"Monitoring Domain '{domain_alias}' already exists (409 Conflict).")
            
            # Interactive prompt as requested
            choice = input("Do you want to continue and create/verify the Monitoring Session? (y/n): ").strip().lower()
            if choice != 'y':
                print("Aborting configuration.")
                sys.exit(1)
            
            print("Attempting to retrieve ID from existing domains again...")
            # Retry GET to find ID with robust parsing
            try:
                resp = requests.get(url, headers=AUTH_HEADERS, verify=False)
                if resp.status_code == 200:
                    data = resp.json()
                    if isinstance(data, dict) and 'monitoringDomains' in data:
                        domains = data['monitoringDomains']
                    elif isinstance(data, list):
                        domains = data
                    else:
                        domains = []
                    
                    for d in domains:
                        if isinstance(d, dict) and d.get('alias') == domain_alias:
                            print(f"Found existing Domain ID: {d.get('id')}")
                            return d.get('id')
            except Exception as e:
                print(f"Retry GET failed: {e}")
            
            # Fallback: Ask (User likely has FM open)
            print("[!] Could not retrieve ID for existing domain automatically.")
            manual_id = input("Please paste the Monitoring Domain ID from FM (or press Enter to skip Session creation): ").strip()
            if manual_id:
                return manual_id
            
            return None
        else:
            print(f"Failed to create Monitoring Domain. API returned {response.status_code}")
            print(f"Response: {response.text}")
            return None
    except Exception as e:
        print(f"Error creating domain: {e}")
        return None

def create_anycloud_connection(domain_id, connection_alias):
    """Creates the AnyCloud Connection (Session) via FM API."""
    if not domain_id:
        print("Skipping Connection/Session creation (No Domain ID).")
        return

    url = f"{FM_URL}/api/v1.3/cloud/anyCloud/connections"

    print(f"\nCreating AnyCloud Connection '{connection_alias}'...")

    payload = {
        "alias": connection_alias,
        "monitoringDomainId": domain_id,
        "secureMirrorTraffic": False
    }

    try:
        response = requests.post(url, json=payload, headers=AUTH_HEADERS, verify=False)
        print(f"POST Response Code: {response.status_code}")
        
        if response.status_code in [200, 201]:
            print(f"Successfully created AnyCloud Connection '{connection_alias}'.")
        elif response.status_code == 409:
            print(f"AnyCloud Connection '{connection_alias}' already exists.")
        else:
            print(f"Failed to create Connection. API returned {response.status_code}")
            print(f"Response: {response.text}")
            
    except Exception as e:
        print(f"Error creating connection: {e}")


def main():
    print("---------------------------------------------------------")
    print("   Gigamon V Series - Post-Deployment Configuration")
    print("---------------------------------------------------------")

    if not check_fm_accessible():
        print("FM is not reachable. Is the VM running?")
        sys.exit(1)

    # 1. Get FM API token (prompts if not hardcoded)
    agent_token = get_auth_token()

    # Build auth headers from the token
    global AUTH_HEADERS
    AUTH_HEADERS = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "Authorization": f"Bearer {agent_token}"
    }

    monitoring_domain = FM_GROUP
    subgroup_name = FM_SUBGROUP

    os.system('cls' if os.name == 'nt' else 'clear')
    print("\n" + "="*60)
    print("Configuration Summary")
    print("="*60)
    print(f"  FM:               {FM_URL}")
    print(f"  Monitoring Domain: {monitoring_domain}")
    print(f"  Connection:        {subgroup_name}")
    print(f"  UCT-V Controller:  {UCTV_PUBLIC_IP} (private: {UCTV_IP})")
    print(f"  vSeries:           {VSERIES_PUBLIC_IP}")
    print(f"  Prod VMs:          {', '.join(PROD_IPS)}")
    print()

    # 2. FM API Configuration (Monitoring Domain)
    print("--- Step 1/2: FM API Configuration ---")
    print(f"Creating Monitoring Domain '{monitoring_domain}'...")

    domain_id = create_monitoring_domain(monitoring_domain)

    if domain_id:
        create_anycloud_connection(domain_id, subgroup_name)
    else:
        print("\n[WARNING] Monitoring Domain creation failed or skipped.")
        print("Agents *may* fail to register if the domain does not exist in FM.")
        input("Press Enter to continue with Agent Configuration (or Ctrl+C to abort)...")

    # 3. Configure Agents (SSH)
    print("\n--- Step 2/2: Agent Configuration (SSH) ---")

    print(f"\n[1/3] Configuring UCT-V Controller ({UCTV_PUBLIC_IP})...")
    push_registration_token(UCTV_PUBLIC_IP, agent_token, remote_address=FM_IP, remote_port=443)

    print(f"\n[2/3] Configuring vSeries Node ({VSERIES_PUBLIC_IP})...")
    push_registration_token(VSERIES_PUBLIC_IP, agent_token, remote_address=FM_IP, remote_port=443)

    print(f"\n[3/3] Configuring Production VMs...")
    for ip in PROD_IPS:
        if ip:
            print(f"  -> {ip}")
            push_registration_token(ip, agent_token, remote_address=UCTV_IP, remote_port=8892)

    print("\n" + "="*60)
    print("Configuration Complete!")
    print("="*60)
    print(f"  Verify in FM:  {FM_URL}/app/#/cloud/monitoringDomains")
    print(f"  Domain:        {monitoring_domain}")
    print(f"  Connection:    {subgroup_name}")
    print("\nCheck FM Inventory for registered UCT-V Controllers and vSeries nodes.")
    print("="*60)

if __name__ == "__main__":
    main()
