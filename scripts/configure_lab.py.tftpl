import argparse
import requests
import time
import json
import sys
import subprocess
import urllib3
import getpass
import os

# Suppress insecure request warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ==============================================================================
# CONFIGURATION (Populated by Terraform)
# ==============================================================================
FM_IP = "${fm_ip}"
FM_URL = f"https://{FM_IP}"
UCTV_IP = "${uctv_ip}"
UCTV_PUBLIC_IP = "${uctv_public_ip}"
VSERIES_PUBLIC_IP = "${vseries_public_ip}"
TOOL_PUBLIC_IP = "${tool_public_ip}"
PROD_IPS = "${prod_ips}".split(",")
KEY_PATH = "${key_path}"
USERNAME = "${username}"

# FM Configuration Defaults
FM_GROUP = "${fm_group}"
FM_SUBGROUP = "${fm_subgroup}"

# Azure Context (for Monitoring Domain)
SUBSCRIPTION_ID = "${subscription_id}"
TENANT_ID = "${tenant_id}"

def run_ssh_command(ip, command, use_sudo=False):
    """Runs a command on a remote VM via SSH."""
    ssh_cmd = [
        "ssh",
        "-o", "StrictHostKeyChecking=no",
        "-o", "UserKnownHostsFile=/dev/null",
        "-tt", # Force pseudo-tty allocation
        "-i", KEY_PATH,
        f"{USERNAME}@{ip}",
    ]
    
    if use_sudo:
        command = f"sudo {command}"
        
    ssh_cmd.append(command)
    
    print(f"DEBUG: Running SSH: {' '.join(ssh_cmd)}")

    try:
        # We need to capture output but -tt might mess with it slightly.
        # However, it's necessary for sudo.
        result = subprocess.run(ssh_cmd, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error running SSH command on {ip} (Exit Code {e.returncode}):")
        print(f"  STDOUT: {e.stdout}")
        print(f"  STDERR: {e.stderr}")
        return None

def check_fm_accessible():
    """Checks if FM is reachable."""
    url = f"{FM_URL}/api/v1.2/authen" # Only checking reachability, not auth
    print(f"Checking connectivity to FM at {FM_IP}...")
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
    }
    try:
        requests.get(url, verify=False, timeout=5, headers=headers)
        return True
    except requests.exceptions.RequestException:
        print("FM is not yet accessible. Please ensure the VM is running and web server is up.")
        return False

def get_user_token():
    """Prompts the user for the FM API Token."""
    print("\n" + "="*60)
    print("ACTION REQUIRED: GigaVUE-FM Authentication")
    print("="*60)
    print(f"1. Log in to GigaVUE-FM: {FM_URL}")
    print("   (Default credentials: admin / admin123A!!)")
    print("2. Accept the EULA and change the password as prompted.")
    print("3. Navigate to: Settings > Authentication > GigaVUE-FM User Management > Tokens")
    print("4. Create a fabric management token and copy it.")
    print("="*60)
    
    while True:
        token = input("\nPaste your FM API Token here: ").strip()
        if token:
            return token
        print("Token cannot be empty.")

def create_monitoring_domain(token, domain_alias):
    """Creates the Monitoring Domain via FM API using 'anyCloud' platform."""
    
    # User specified v1.3
    # If FM is older, v1.2 might work with same payload, but let's try v1.3 first as requested.
    url = f"{FM_URL}/api/v1.3/cloud/monitoringDomains"
    
    headers = {
        "Authorization": f"Bearer {token}",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        "Content-Type": "application/json"
    }

    # 1. Check existence
    print(f"Checking for existing domain at: {url}")
    try:
        resp = requests.get(url, headers=headers, verify=False)
        print(f"GET Response Code: {resp.status_code}")
        
        if resp.status_code == 200:
            try:
                data = resp.json()
                print(f"DEBUG: Domains Raw Response: {json.dumps(data, indent=2)}")
                
                # Handle wrapped response (common in Gigamon APIs)
                if isinstance(data, dict) and 'monitoringDomains' in data:
                    domains = data['monitoringDomains']
                elif isinstance(data, list):
                    domains = data
                else:
                    domains = [data] if isinstance(data, dict) else []

                for d in domains:
                    # Handle if d is a dict (expected)
                    if isinstance(d, dict) and d.get('alias') == domain_alias:
                        print(f"Monitoring Domain '{domain_alias}' already exists (ID: {d.get('id')}).")
                        return d.get('id')
                        
            except ValueError:
                print(f"GET Response was not JSON: {resp.text}")
                
        else:
            print(f"Failed to list domains. Status: {resp.status_code}")
            print(f"Response: {resp.text}")
    except Exception as e:
        print(f"Warning: Could not list cloud domains: {e}")

    # 2. Create
    print(f"\nCreating Monitoring Domain '{domain_alias}'...")
    
    # User provided payload
    payload = {
        "alias": domain_alias,
        "platform": "anyCloud",
        "userLaunched": True,
        "dualStackPreferIPv6": False,
        "mtu": 1450
    }

    try:
        response = requests.post(url, json=payload, headers=headers, verify=False)
        
        # Debugging POST response
        print(f"POST Response Code: {response.status_code}")
        
        if response.status_code in [200, 201]:
            # Try to get ID from response first
            try:
                data = response.json()
                if data and 'id' in data:
                    domain_id = data.get('id')
                    print(f"Successfully created Monitoring Domain (ID: {domain_id}).")
                    return domain_id
            except:
                pass
            
            print(f"POST succeeded ({response.status_code}). Retrieving ID via GET...")
            
            # Attempt to retrieve ID via GET since creation succeeded
            # Wait a moment for consistency?
            time.sleep(2) 
            try:
                resp = requests.get(url, headers=headers, verify=False)
                if resp.status_code == 200:
                    data = resp.json()
                    if isinstance(data, dict) and 'monitoringDomains' in data:
                        domains = data['monitoringDomains']
                    elif isinstance(data, list):
                        domains = data
                    else:
                        domains = []

                    for d in domains:
                        if isinstance(d, dict) and d.get('alias') == domain_alias:
                            print(f"Retrieved ID for newly created Domain: {d.get('id')}")
                            return d.get('id')
            except Exception as e:
                print(f"Error retrieving ID after creation: {e}")
                
            print("[!] Created Domain but could not retrieve ID automatically.")
            return None
                
        elif response.status_code == 409:
            print(f"Monitoring Domain '{domain_alias}' already exists (409 Conflict).")
            
            # Interactive prompt as requested
            choice = input("Do you want to continue and create/verify the Monitoring Session? (y/n): ").strip().lower()
            if choice != 'y':
                print("Aborting configuration.")
                sys.exit(1)
            
            print("Attempting to retrieve ID from existing domains again...")
            # Retry GET to find ID with robust parsing
            try:
                resp = requests.get(url, headers=headers, verify=False)
                if resp.status_code == 200:
                    data = resp.json()
                    if isinstance(data, dict) and 'monitoringDomains' in data:
                        domains = data['monitoringDomains']
                    elif isinstance(data, list):
                        domains = data
                    else:
                        domains = []
                    
                    for d in domains:
                        if isinstance(d, dict) and d.get('alias') == domain_alias:
                            print(f"Found existing Domain ID: {d.get('id')}")
                            return d.get('id')
            except Exception as e:
                print(f"Retry GET failed: {e}")
            
            # Fallback: Ask (User likely has FM open)
            print("[!] Could not retrieve ID for existing domain automatically.")
            manual_id = input("Please paste the Monitoring Domain ID from FM (or press Enter to skip Session creation): ").strip()
            if manual_id:
                return manual_id
            
            return None
        else:
            print(f"Failed to create Monitoring Domain. API returned {response.status_code}")
            print(f"Response: {response.text}")
            return None
    except Exception as e:
        print(f"Error creating domain: {e}")
        return None

def create_anycloud_connection(token, domain_id, connection_alias):
    """Creates the AnyCloud Connection (Session) via FM API."""
    if not domain_id:
        print("Skipping Connection/Session creation (No Domain ID).")
        return

    # User specified endpoint for AnyCloud connection
    url = f"{FM_URL}/api/v1.3/cloud/anyCloud/connections"
    
    headers = {
        "Authorization": f"Bearer {token}",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        "Content-Type": "application/json"
    }
    
    print(f"\nCreating AnyCloud Connection '{connection_alias}'...")
    
    # User provided payload
    payload = {
        "alias": connection_alias,
        "monitoringDomainId": domain_id,
        "secureMirrorTraffic": False
    }
    
    try:
        # Check existence first? The endpoint might be listable
        # But let's try creating directly and handle 409 if needed, matching established pattern
        response = requests.post(url, json=payload, headers=headers, verify=False)
        print(f"POST Response Code: {response.status_code}")
        
        if response.status_code in [200, 201]:
            print(f"Successfully created AnyCloud Connection '{connection_alias}'.")
        elif response.status_code == 409:
            print(f"AnyCloud Connection '{connection_alias}' already exists.")
        else:
            print(f"Failed to create Connection. API returned {response.status_code}")
            print(f"Response: {response.text}")
            
    except Exception as e:
        print(f"Error creating connection: {e}")


def update_vm_config(vm_ip, token, service_name="gigamon-gigavue-uctv", remote_address=None, remote_port=443):
    """Updates the Gigamon agent configuration on a VM."""
    if remote_address is None:
        remote_address = FM_IP  # Default: register with FM
    print(f"Configuring agent on {vm_ip} (Service: {service_name}, RemoteAddress: {remote_address}, RemotePort: {remote_port})...")
    
    # Check if config file exists
    check_file_cmd = "test -f /etc/gigamon-cloud.conf && echo 'FOUND' || echo 'NOT_FOUND'"
    file_status = run_ssh_command(vm_ip, check_file_cmd)
    
    if file_status != 'FOUND':
        print(f"Config file not found on {vm_ip}. Creating it...")
        lines = [
            "Registration:",
            f"  groupName: {FM_GROUP}",
            f"  subGroupName: {FM_SUBGROUP}",
            f"  token: {token}",
            f"  remoteAddress: {remote_address}",
            f"  remotePort: {remote_port}"
        ]
        cmd_str = "\\n".join(lines)
        create_cmd = f"printf '{cmd_str}' | sudo tee /etc/gigamon-cloud.conf"
        
        if run_ssh_command(vm_ip, create_cmd) is None:
             print(f"Failed to create config file on {vm_ip}.")
             return
    else:
        # Update existing file
        print(f"Updating existing config on {vm_ip}...")
        
        # 1. Remove comments (lines starting with # or spaces then #)
        run_ssh_command(vm_ip, "sudo sed -i '/^\\s*#/d' /etc/gigamon-cloud.conf")
        
        # 2. Rename remoteIP -> remoteAddress (backwards compat)
        run_ssh_command(vm_ip, "sudo sed -i 's/remoteIP/remoteAddress/g' /etc/gigamon-cloud.conf")
        
        # 3. Set the correct remoteAddress value
        run_ssh_command(vm_ip, f"sudo sed -i 's|remoteAddress:.*|remoteAddress: {remote_address}|g' /etc/gigamon-cloud.conf")
        
        # 4. Set the correct remotePort value
        run_ssh_command(vm_ip, f"sudo sed -i 's|remotePort:.*|remotePort: {remote_port}|g' /etc/gigamon-cloud.conf")
        
        # 5. Update Token (handle both PLACEHOLDER and PRICEHOLDER just in case)
        sed_cmd = f"sed -i 's/PLACEHOLDER_TOKEN/{token}/g' /etc/gigamon-cloud.conf"
        sed_cmd2 = f"sed -i 's/PRICEHOLDER_TOKEN/{token}/g' /etc/gigamon-cloud.conf"
        
        run_ssh_command(vm_ip, sed_cmd, use_sudo=True)
        run_ssh_command(vm_ip, sed_cmd2, use_sudo=True)

    # Show the final config for verification
    print(f"Final config on {vm_ip}:")
    run_ssh_command(vm_ip, "cat /etc/gigamon-cloud.conf")

    # Restart service
    restart_cmd = f"systemctl restart {service_name}" 
    run_ssh_command(vm_ip, restart_cmd, use_sudo=True)
    print(f"Agent configured and restarted on {vm_ip}.")

def main():
    print("---------------------------------------------------------")
    print("   Gigamon V Series - Post-Deployment Configuration")
    print("---------------------------------------------------------")
    
    if not check_fm_accessible():
        print("FM is not reachable. Is the VM running?")
        sys.exit(1)
        
    # 1. Get Token from User
    token = get_user_token()
    
    # Define variables as requested
    monitoring_domain = FM_GROUP
    subgroup_name = FM_SUBGROUP
    
    # 2. FM API Configuration (Monitoring Domain) - FIRST!
    print("\n--- Creating Monitoring Domain (API) ---")
    print(f"Monitoring Domain: {monitoring_domain}")
    # print(f"Subgroup Name: {subgroup_name}") # Not used for AnyCloud domain creation
    
    # Create Domain (anyCloud type, no connection ID needed)
    domain_id = create_monitoring_domain(token, monitoring_domain)
    
    if domain_id:
        create_anycloud_connection(token, domain_id, subgroup_name)
    else:
        print("\n[WARNING] Monitoring Domain creation failed or skipped.")
        print("Agents *may* fail to register if the domain does not exist in FM.")
        input("Press Enter to continue with Agent Configuration (or Ctrl+C to abort)...")
    
    # 3. Configure Agents (SSH) - SECOND!
    print("\n--- Configuring Agents (SSH) ---")
    
    # UCT-V Controller (Service Name: uctv-cntlr) — registers to FM on port 443
    update_vm_config(UCTV_PUBLIC_IP, token, service_name="uctv-cntlr", remote_port=443)

    # vSeries (Service Name: vseries-node) — registers to FM on port 443
    update_vm_config(VSERIES_PUBLIC_IP, token, service_name="vseries-node", remote_port=443)

    # Prod VMs register with UCT-V Controller (not FM directly) on port 8892
    for ip in PROD_IPS:
        if ip:
            update_vm_config(ip, token, service_name="uctv", remote_address=UCTV_IP, remote_port=8892)

    print("\n---------------------------------------------------------")
    print("Configuration Complete!")
    print(f"Please verify the Monitoring Domain '{monitoring_domain}' in FM.")
    print("---------------------------------------------------------")

if __name__ == "__main__":
    main()
