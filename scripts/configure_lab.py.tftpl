import argparse
import requests
import time
import json
import sys
import subprocess
import urllib3
import getpass
import os

# Suppress insecure request warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ==============================================================================
# CONFIGURATION (Populated by Terraform)
# ==============================================================================
FM_IP = "${fm_ip}"
FM_URL = f"https://{FM_IP}"
UCTV_IP = "${uctv_ip}"
UCTV_PUBLIC_IP = "${uctv_public_ip}"
VSERIES_PUBLIC_IP = "${vseries_public_ip}"
TOOL_PUBLIC_IP = "${tool_public_ip}"
PROD_IPS = "${prod_ips}".split(",")
KEY_PATH = "${key_path}"
USERNAME = "${username}"

# FM Configuration Defaults
FM_GROUP = "${fm_group}"
FM_SUBGROUP = "${fm_subgroup}"

# Azure Context (for Monitoring Domain)
SUBSCRIPTION_ID = "${subscription_id}"
TENANT_ID = "${tenant_id}"

def run_ssh_command(ip, command, use_sudo=False):
    """Runs a command on a remote VM via SSH."""
    ssh_cmd = [
        "ssh",
        "-o", "StrictHostKeyChecking=no",
        "-o", "UserKnownHostsFile=/dev/null",
        "-tt", # Force pseudo-tty allocation
        "-i", KEY_PATH,
        f"{USERNAME}@{ip}",
    ]
    
    if use_sudo:
        command = f"sudo {command}"
        
    ssh_cmd.append(command)
    
    print(f"DEBUG: Running SSH: {' '.join(ssh_cmd)}")

    try:
        # We need to capture output but -tt might mess with it slightly.
        # However, it's necessary for sudo.
        result = subprocess.run(ssh_cmd, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error running SSH command on {ip} (Exit Code {e.returncode}):")
        print(f"  STDOUT: {e.stdout}")
        print(f"  STDERR: {e.stderr}")
        return None

def check_fm_accessible():
    """Checks if FM is reachable."""
    url = f"{FM_URL}/api/v1.2/authen" # Only checking reachability, not auth
    print(f"Checking connectivity to FM at {FM_IP}...")
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
    }
    try:
        resp = requests.get(url, verify=False, timeout=5, headers=headers)
        if resp.status_code >= 500:
            print(f"FM web server is up, but API backend is not ready (HTTP {resp.status_code}). Waiting...")
            return False
        return True
    except requests.exceptions.RequestException:
        print("FM is not yet accessible (socket error). Please ensure the VM is running.")
        return False

def get_user_token():
    """Automates FM login, user creation, and token generation."""
    print("\n" + "="*60)
    print("Automating GigaVUE-FM Authentication & User Creation")
    print("="*60)
    
    # 1. Login as admin
    login_url = f"{FM_URL}/api/v1.2/authen"
    headers = {"Content-Type": "application/json"}
    login_data = {"username": "admin", "password": "admin123A!!"}
    
    print("Logging into FM as admin...")
    try:
        resp = requests.post(login_url, json=login_data, headers=headers, verify=False, timeout=10)
        resp.raise_for_status()
        admin_token = resp.json().get("token")
        if not admin_token:
            print("Failed to get token from login response.")
            sys.exit(1)
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 401:
            print("Initial login failed (401). The default password might have already been changed.")
            print("Please ensure the FM instance is fresh or modify the script with the current password.")
            sys.exit(1)
        print(f"Login failed (HTTP {e.response.status_code}): {e.response.text}")
        sys.exit(1)
    except ValueError:
        print(f"API returned non-JSON response. It might still be booting up. Response:\n{resp.text}")
        sys.exit(1)
    except Exception as e:
        print(f"Connection error: {e}")
        sys.exit(1)

    # 2. Accept EULA (sometimes required on fresh boot before APIs work)
    auth_headers = {
        "Authorization": f"Bearer {admin_token}",
        "Content-Type": "application/json"
    }
    
    eula_url = f"{FM_URL}/api/v1.3/auth/users/eula"
    print("Accepting EULA...")
    requests.post(eula_url, headers=auth_headers, verify=False)

    # 3. Create 'peter' user (if it doesn't exist)
    user_url = f"{FM_URL}/api/v1.3/auth/users"
    peter_data = {
        "userName": "peter",
        "firstName": "Peter",
        "lastName": "Admin",
        "password": "Gigamon123A!!!",
        "confirmPassword": "Gigamon123A!!!",
        "email": "pete.connolly@gigamon.com",
        "roles": [{"name": "admin_role"}],
        "isActive": True
    }
    
    print("Creating user 'peter'...")
    try:
        resp = requests.post(user_url, json=peter_data, headers=auth_headers, verify=False)
        if resp.status_code in [200, 201]:
            print("User 'peter' created successfully.")
        elif resp.status_code == 409:
            print("User 'peter' already exists. Reusing existing user.")
        else:
            print(f"Failed to create user. Status: {resp.status_code}")
            print(resp.text)
    except Exception as e:
        print(f"Error creating user: {e}")

    # 4. Login as 'peter' to get a token for them
    print("Logging in as 'peter' to generate token...")
    peter_login_data = {"username": "peter", "password": "Gigamon123A!!!"}
    try:
        resp = requests.post(login_url, json=peter_login_data, headers=headers, verify=False)
        resp.raise_for_status()
        peter_token = resp.json().get("token")
        
        # 5. Create a long-lived API token for peter
        token_url = f"{FM_URL}/api/v1.3/auth/tokens"
        token_auth_headers = {"Authorization": f"Bearer {peter_token}", "Content-Type": "application/json"}
        token_data = {"name": "Lab_Registration_Token", "description": "Token for agent registration", "duration": 86400}
        
        print("Generating API token for 'peter'...")
        t_resp = requests.post(token_url, json=token_data, headers=token_auth_headers, verify=False)
        if t_resp.status_code in [200, 201]:
            final_token = t_resp.json().get("token")
            if final_token:
                print("API Token generated successfully!")
                return final_token
                
        # Fallback to the session token if permanent token creation fails
        print("Using session token as fallback.")
        return peter_token
        
    except Exception as e:
        print(f"Failed to generate token for peter: {e}")
        # If peter login fails, pass the admin token so the script at least works
        print("Falling back to admin token.")
        return admin_token

def create_monitoring_domain(token, domain_alias):
    """Creates the Monitoring Domain via FM API using 'anyCloud' platform."""
    
    # User specified v1.3
    # If FM is older, v1.2 might work with same payload, but let's try v1.3 first as requested.
    url = f"{FM_URL}/api/v1.3/cloud/monitoringDomains"
    
    headers = {
        "Authorization": f"Bearer {token}",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        "Content-Type": "application/json"
    }

    # 1. Check existence
    print(f"Checking for existing domain at: {url}")
    try:
        resp = requests.get(url, headers=headers, verify=False)
        print(f"GET Response Code: {resp.status_code}")
        
        if resp.status_code == 200:
            try:
                data = resp.json()
                print(f"DEBUG: Domains Raw Response: {json.dumps(data, indent=2)}")
                
                # Handle wrapped response (common in Gigamon APIs)
                if isinstance(data, dict) and 'monitoringDomains' in data:
                    domains = data['monitoringDomains']
                elif isinstance(data, list):
                    domains = data
                else:
                    domains = [data] if isinstance(data, dict) else []

                for d in domains:
                    # Handle if d is a dict (expected)
                    if isinstance(d, dict) and d.get('alias') == domain_alias:
                        print(f"Monitoring Domain '{domain_alias}' already exists (ID: {d.get('id')}).")
                        return d.get('id')
                        
            except ValueError:
                print(f"GET Response was not JSON: {resp.text}")
                
        else:
            print(f"Failed to list domains. Status: {resp.status_code}")
            print(f"Response: {resp.text}")
    except Exception as e:
        print(f"Warning: Could not list cloud domains: {e}")

    # 2. Create
    print(f"\nCreating Monitoring Domain '{domain_alias}'...")
    
    # User provided payload
    payload = {
        "alias": domain_alias,
        "platform": "anyCloud",
        "userLaunched": True,
        "dualStackPreferIPv6": False,
        "mtu": 1450
    }

    try:
        response = requests.post(url, json=payload, headers=headers, verify=False)
        
        # Debugging POST response
        print(f"POST Response Code: {response.status_code}")
        
        if response.status_code in [200, 201]:
            # Try to get ID from response first
            try:
                data = response.json()
                if data and 'id' in data:
                    domain_id = data.get('id')
                    print(f"Successfully created Monitoring Domain (ID: {domain_id}).")
                    return domain_id
            except:
                pass
            
            print(f"POST succeeded ({response.status_code}). Retrieving ID via GET...")
            
            # Attempt to retrieve ID via GET since creation succeeded
            # Wait a moment for consistency?
            time.sleep(2) 
            try:
                resp = requests.get(url, headers=headers, verify=False)
                if resp.status_code == 200:
                    data = resp.json()
                    if isinstance(data, dict) and 'monitoringDomains' in data:
                        domains = data['monitoringDomains']
                    elif isinstance(data, list):
                        domains = data
                    else:
                        domains = []

                    for d in domains:
                        if isinstance(d, dict) and d.get('alias') == domain_alias:
                            print(f"Retrieved ID for newly created Domain: {d.get('id')}")
                            return d.get('id')
            except Exception as e:
                print(f"Error retrieving ID after creation: {e}")
                
            print("[!] Created Domain but could not retrieve ID automatically.")
            return None
                
        elif response.status_code == 409:
            print(f"Monitoring Domain '{domain_alias}' already exists (409 Conflict).")
            
            # Interactive prompt as requested
            choice = input("Do you want to continue and create/verify the Monitoring Session? (y/n): ").strip().lower()
            if choice != 'y':
                print("Aborting configuration.")
                sys.exit(1)
            
            print("Attempting to retrieve ID from existing domains again...")
            # Retry GET to find ID with robust parsing
            try:
                resp = requests.get(url, headers=headers, verify=False)
                if resp.status_code == 200:
                    data = resp.json()
                    if isinstance(data, dict) and 'monitoringDomains' in data:
                        domains = data['monitoringDomains']
                    elif isinstance(data, list):
                        domains = data
                    else:
                        domains = []
                    
                    for d in domains:
                        if isinstance(d, dict) and d.get('alias') == domain_alias:
                            print(f"Found existing Domain ID: {d.get('id')}")
                            return d.get('id')
            except Exception as e:
                print(f"Retry GET failed: {e}")
            
            # Fallback: Ask (User likely has FM open)
            print("[!] Could not retrieve ID for existing domain automatically.")
            manual_id = input("Please paste the Monitoring Domain ID from FM (or press Enter to skip Session creation): ").strip()
            if manual_id:
                return manual_id
            
            return None
        else:
            print(f"Failed to create Monitoring Domain. API returned {response.status_code}")
            print(f"Response: {response.text}")
            return None
    except Exception as e:
        print(f"Error creating domain: {e}")
        return None

def create_anycloud_connection(token, domain_id, connection_alias):
    """Creates the AnyCloud Connection (Session) via FM API."""
    if not domain_id:
        print("Skipping Connection/Session creation (No Domain ID).")
        return

    # User specified endpoint for AnyCloud connection
    url = f"{FM_URL}/api/v1.3/cloud/anyCloud/connections"
    
    headers = {
        "Authorization": f"Bearer {token}",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        "Content-Type": "application/json"
    }
    
    print(f"\nCreating AnyCloud Connection '{connection_alias}'...")
    
    # User provided payload
    payload = {
        "alias": connection_alias,
        "monitoringDomainId": domain_id,
        "secureMirrorTraffic": False
    }
    
    try:
        # Check existence first? The endpoint might be listable
        # But let's try creating directly and handle 409 if needed, matching established pattern
        response = requests.post(url, json=payload, headers=headers, verify=False)
        print(f"POST Response Code: {response.status_code}")
        
        if response.status_code in [200, 201]:
            print(f"Successfully created AnyCloud Connection '{connection_alias}'.")
        elif response.status_code == 409:
            print(f"AnyCloud Connection '{connection_alias}' already exists.")
        else:
            print(f"Failed to create Connection. API returned {response.status_code}")
            print(f"Response: {response.text}")
            
    except Exception as e:
        print(f"Error creating connection: {e}")


def update_vm_config(vm_ip, token, service_name="gigamon-gigavue-uctv", remote_address=None, remote_port=443):
    """Updates the Gigamon agent configuration on a VM."""
    if remote_address is None:
        remote_address = FM_IP  # Default: register with FM
    print(f"Configuring agent on {vm_ip} (Service: {service_name}, RemoteAddress: {remote_address}, RemotePort: {remote_port})...")
    
    # Check if config file exists
    check_file_cmd = "test -f /etc/gigamon-cloud.conf && echo 'FOUND' || echo 'NOT_FOUND'"
    file_status = run_ssh_command(vm_ip, check_file_cmd)
    
    if file_status != 'FOUND':
        print(f"Config file not found on {vm_ip}. Creating it...")
        lines = [
            "Registration:",
            f"  groupName: {FM_GROUP}",
            f"  subGroupName: {FM_SUBGROUP}",
            f"  token: {token}",
            f"  remoteAddress: {remote_address}",
            f"  remotePort: {remote_port}"
        ]
        cmd_str = "\\n".join(lines)
        create_cmd = f"printf '{cmd_str}' | sudo tee /etc/gigamon-cloud.conf"
        
        if run_ssh_command(vm_ip, create_cmd) is None:
             print(f"Failed to create config file on {vm_ip}.")
             return
    else:
        # Update existing file
        print(f"Updating existing config on {vm_ip}...")
        
        # 1. Remove comments (lines starting with # or spaces then #)
        run_ssh_command(vm_ip, "sudo sed -i '/^\\s*#/d' /etc/gigamon-cloud.conf")
        
        # 2. Rename remoteIP -> remoteAddress (backwards compat)
        run_ssh_command(vm_ip, "sudo sed -i 's/remoteIP/remoteAddress/g' /etc/gigamon-cloud.conf")
        
        # 3. Set the correct remoteAddress value
        run_ssh_command(vm_ip, f"sudo sed -i 's|remoteAddress:.*|remoteAddress: {remote_address}|g' /etc/gigamon-cloud.conf")
        
        # 4. Set the correct remotePort value
        run_ssh_command(vm_ip, f"sudo sed -i 's|remotePort:.*|remotePort: {remote_port}|g' /etc/gigamon-cloud.conf")
        
        # 5. Update Token (handle both PLACEHOLDER and PRICEHOLDER just in case)
        sed_cmd = f"sed -i 's/PLACEHOLDER_TOKEN/{token}/g' /etc/gigamon-cloud.conf"
        sed_cmd2 = f"sed -i 's/PRICEHOLDER_TOKEN/{token}/g' /etc/gigamon-cloud.conf"
        
        run_ssh_command(vm_ip, sed_cmd, use_sudo=True)
        run_ssh_command(vm_ip, sed_cmd2, use_sudo=True)

    # Show the final config for verification
    print(f"Final config on {vm_ip}:")
    run_ssh_command(vm_ip, "cat /etc/gigamon-cloud.conf")

    # Restart service
    restart_cmd = f"systemctl restart {service_name}" 
    run_ssh_command(vm_ip, restart_cmd, use_sudo=True)
    print(f"Agent configured and restarted on {vm_ip}.")

def main():
    print("---------------------------------------------------------")
    print("   Gigamon V Series - Post-Deployment Configuration")
    print("---------------------------------------------------------")
    
    if not check_fm_accessible():
        print("FM is not reachable. Is the VM running?")
        sys.exit(1)
        
    # 1. Get Token from User
    token = get_user_token()
    
    # Define variables as requested
    monitoring_domain = FM_GROUP
    subgroup_name = FM_SUBGROUP
    
    # 2. FM API Configuration (Monitoring Domain) - FIRST!
    print("\n--- Creating Monitoring Domain (API) ---")
    print(f"Monitoring Domain: {monitoring_domain}")
    # print(f"Subgroup Name: {subgroup_name}") # Not used for AnyCloud domain creation
    
    # Create Domain (anyCloud type, no connection ID needed)
    domain_id = create_monitoring_domain(token, monitoring_domain)
    
    if domain_id:
        create_anycloud_connection(token, domain_id, subgroup_name)
    else:
        print("\n[WARNING] Monitoring Domain creation failed or skipped.")
        print("Agents *may* fail to register if the domain does not exist in FM.")
        input("Press Enter to continue with Agent Configuration (or Ctrl+C to abort)...")
    
    # 3. Configure Agents (SSH) - SECOND!
    print("\n--- Configuring Agents (SSH) ---")
    
    # UCT-V Controller (Service Name: uctv-cntlr) — registers to FM on port 443
    update_vm_config(UCTV_PUBLIC_IP, token, service_name="uctv-cntlr", remote_port=443)

    # vSeries (Service Name: vseries-node) — registers to FM on port 443
    update_vm_config(VSERIES_PUBLIC_IP, token, service_name="vseries-node", remote_port=443)

    # Prod VMs register with UCT-V Controller (not FM directly) on port 8892
    for ip in PROD_IPS:
        if ip:
            update_vm_config(ip, token, service_name="uctv", remote_address=UCTV_IP, remote_port=8892)

    print("\n---------------------------------------------------------")
    print("Configuration Complete!")
    print(f"Please verify the Monitoring Domain '{monitoring_domain}' in FM.")
    print("---------------------------------------------------------")

if __name__ == "__main__":
    main()
